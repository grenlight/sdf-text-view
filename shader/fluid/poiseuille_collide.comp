// layout (local_size_x = 1, local_size_y = 1) in;

layout(set = 0, binding = 0) uniform FluidUniform {
    // 表示D2Q9离散速度模型速度空间的速度配置
    vec2 e[9];
    // lattice 在正规化坐标空间的大小
    vec2 lattice_size;
    vec2 lattice_num;
    float weight[9];
    // 0： f_tex10， 1: f_tex11
    int swap;
};

// 中心点的参数：r = source f_i 0, g = dst f_i 0
layout(binding = 1, rgba32f) uniform image2D f00;
layout(binding = 2, rgba32f) uniform image2D f10;
layout(binding = 3, rgba32f) uniform image2D f20;
layout(binding = 4, rgba32f) uniform image2D f11;
layout(binding = 5, rgba32f) uniform image2D f21;
// rgb:表示宏观速度密度
layout(binding = 6, rgba32f) uniform image2D macro_param;

const float Gamma[9] = float[]( 0.0, 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/12.0, 1.0/12.0, 1.0/12.0, 1.0/12.0);

// Cs 表示声速
const float Cs2 = 1.0 / 3.0;
// 流体特征
const float physCharLength   = 1.0;
const float physCharVelocity = 1.0;
const float physViscosity    = 0.01;
const float latticeCharVelocity = 0.01;
// 单位变换
const float resolution    = 100.0;
const float convLength    = physCharLength / resolution;
const float convTime      = latticeCharVelocity / physCharVelocity * physCharLength / resolution;
const float convVelocity  = convLength / convTime;
const float convViscosity = convLength * convLength / convTime;

const float tau = physViscosity / convViscosity * Cs2 + 0.5;
//弛豫时间
const float relaxationFrequency = 1.0 / tau;

/// Emergent fluid numbers
// 雷诺数 = UL/v 
const float Re = physCharVelocity * physCharLength / physViscosity;
// 为了获得比较好的模拟效果，马赫数需要确保比较小
// Ma = U/Cs， U 为宏观流速，为了减小误差，特征流速需要设定成比较小的值，最好不要超过 0.1
const float Ma = latticeCharVelocity * sqrt(Cs2);
const float Kn = Ma / Re;

const vec2 force = vec2(0.01, 0.0);

void main() {
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

    vec4 f0 = imageLoad(f00, uv);
    vec4 f1 =  (swap == 0) ? imageLoad(f10, uv) : imageLoad(f11, uv);
    vec4 f2 = (swap == 0) ? imageLoad(f20, uv) : imageLoad(f21, uv);

    float f_i[9] = float[](f0.r, f1.r, f1.g, f1.b, f1.a, f2.r, f2.g, f2.b, f2.a); 

    //格子点的迁移过程
    vec2 velocity = vec2(0.0);
    float rho = 0.0;
    // if (uv.x > 20 && uv.x < 30) {
    //     velocity = vec2(0.2, 0.3);
    //     rho = 1.0;
    // } 
    if (uv.x == 0 || uv.x == int(lattice_num.x - 1.0) || uv.y == 0 || uv.y == int(lattice_num.y - 1.0)) {
        // rho = 1.0;
        // velocity = vec2(0.01, 0.0);

    } 
    else {
        for (int i = 0; i < 9; i++) {
            rho += f_i[i];
            // U = sum_fi*ei / rho
            velocity += e[i] * f_i[i];
        }
        if (rho == 0.0) {
            velocity = vec2(0.01, 0.0);
        } else {
            velocity = velocity / rho;
        }
        // velocity.x += 0.1;
        imageStore(macro_param, uv, vec4(velocity, rho, 1.0));
    }

    // 更新包分布
    float collide[9];  
    if (uv.x == 0 || uv.x == int(lattice_num.x - 1.0) || uv.y == 0 || uv.y == int(lattice_num.y - 1.0)) {
        // for (int i = 0; i < 9; i++) {
        // // D2Q9包分布公式
        // float e_dot_u = dot(e[i], velocity);
        // // 均衡分布
        // // pow(x, y) 要求 x 参数不能为负，e_dot_u 是有可能为负的，所以求它的平方不能用  pow 内置函数
        // // 当 i == 0 时，feq = rho * weight[i] * (1.0 - 1.5 * dot(velocity, velocity) / Cs2);
        // collide[i] = rho * weight[i] * (1.0 + 3 * e_dot_u / Cs2 + 4.5 * (e_dot_u * e_dot_u) / pow(Cs2, 2.0) - 1.5 * dot(velocity, velocity) / Cs2);
  
        // }
    } else {
    for (int i = 0; i < 9; i++) {
        // D2Q9包分布公式
        float e_dot_u = dot(e[i], velocity);
        // 均衡分布
        // pow(x, y) 要求 x 参数不能为负，e_dot_u 是有可能为负的，所以求它的平方不能用  pow 内置函数
        // 当 i == 0 时，feq = rho * weight[i] * (1.0 - 1.5 * dot(velocity, velocity) / Cs2);
        float feq = rho * weight[i] * (1.0 + 3 * e_dot_u / Cs2 + 4.5 * (e_dot_u * e_dot_u) / pow(Cs2, 2.0) - 1.5 * dot(velocity, velocity) / Cs2);
  
        // 碰撞
        collide[i] = f_i[i] - relaxationFrequency * (f_i[i] - feq);
        // 体力驱动
        // collide[i] = collide[i] + Gamma[i] * (dot(e[i], force));
    }
        
    }
    f0.g = collide[0];
        imageStore(f11, uv, vec4(collide[1], collide[2], collide[3], collide[4]));
        imageStore(f21, uv, vec4(collide[5], collide[6], collide[7], collide[8]));
        imageStore(f00, uv, f0);
}