layout (local_size_x = 1, local_size_y = 1) in;

layout(set = 0, binding = 0) uniform FluidUniform {
    // 表示D2Q9离散速度模型速度空间的速度配置
    vec2 e[9];
    // lattice 在正规化坐标空间的大小
    vec2 lattice_size;
    vec2 lattice_num;
    float weight[9];
    // 0： f_tex10， 1: f_tex11
    int swap;
};

// 中心点的参数：r = source f_i 0, g = dst f_i 0
layout(binding = 1, rgba32f) uniform image2D f00;
layout(binding = 2, rgba32f) uniform image2D f10;
layout(binding = 3, rgba32f) uniform image2D f20;
layout(binding = 4, rgba32f) uniform image2D f11;
layout(binding = 5, rgba32f) uniform image2D f21;
// rgb:表示宏观速度密度
layout(binding = 6, rgba32f) uniform image2D macro_param;   

const vec2 velocity = vec2(0.05, 0.0);
const float rho = 1.0;
// Cs 表示声速
const float Cs2 = 1.0 / 3.0;

void main() {
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    // uv += ivec2(1, 1);
    
    float f[9];  
    for (int i = 0; i < 9; i++) {
        // D2Q9包分布公式
        float e_dot_u = dot(e[i], velocity);
        // 平衡分布值做为初始值：Fi = Feq(rho0, U0)
        f[i] = rho * weight[i] * (1.0 + 3 * e_dot_u / Cs2 + 4.5 * (e_dot_u * e_dot_u) / pow(Cs2, 2.0) - 1.5 * dot(velocity, velocity) / Cs2);
    }
    imageStore(f00, uv, vec4(f[0], f[0], 0.0, 1.0));
	// imageStore(f10, uv, vec4(f[1], f[2], f[3], f[4]));
    // imageStore(f20, uv, vec4(f[5], f[6], f[7], f[8]));
	imageStore(f11, uv, vec4(f[1], f[2], f[3], f[4]));
    imageStore(f21, uv, vec4(f[5], f[6], f[7], f[8]));

    imageStore(macro_param, uv, vec4(0.0, 0.0, 0.0, 1.0));

}